#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define TAM 14
#define COR 6
#define TENT 10

//TAM corresponds to the size of the matrix, assuming it has the same number of lines and columns
//COR determines the set of values used to populate the matrix, ranging from 0 to COR -1
//TENT measures the number of plays allowed before the game ends


typedef struct {
    
    int i;
	int j;
    int contador;
	int tab[TAM][TAM];
	int comando;
	int *alt;
} Jogo;

Jogo novoTabuleiro() {
	Jogo a = {0, 0, 1};
	
	srand( (unsigned)time(NULL) );

	for(a.i = 0; a.i < TAM; a.i++) {
		for(a.j = 0; a.j < TAM; a.j++) {
			a.tab[a.i][a.j] = rand() % COR;
		}
	}
	return a;
	
//generates random numbers in the [0,5] interval and sets them to each position in the matrix

}

void imprime (Jogo a) {

	printf("\t\t\t*=*=*=*=*FLOOD IT!*=*=*=*=*\n\n");


	for(a.i = 0; a.i < TAM; a.i++) {
		
		printf("\t\t\t");
		
		for(a.j = 0; a.j < TAM; a.j++) {
			printf("%i ", a.tab[a.i][a.j]);
		}
	printf("\n");
	}
}

//prints each element to the screen and then, when i's value increases, prints a line break to give the matrix its shape


Jogo analisar(Jogo a, Jogo b) {
    
    if(b.tab[b.i-1][b.j] == a.tab[0][0]) {
        
        b.tab[b.i-1][b.j] = a.comando;
        
        b.i--;
        
        analisar(a, b);
        
    }
    
    b.i = 1;
    
    if(b.tab[b.i][b.j-1] == a.tab[0][0]) {
        
         b.tab[b.i][b.j-1] = a.comando;
        
        b.j--;
        
        analisar(a, b);
        
    }
    
    b.j = 1;
    
    if(b.tab[b.i+1][b.j] == a.tab[0][0]) {
        
        b.tab[b.i+1][b.j] = a.comando;
        
        b.i--;
        
        analisar(a, b);
        
    }
    
    b.i = 1;
    
    if(b.tab[b.i][b.j+1] == a.tab[0][0]) {
        
         b.tab[b.i][b.j+1] = a.comando;
        
        b.j--;
        
        analisar(a, b);
        
    }
    
    b.j = 1;
    
    return b;
    
}

void jogada (Jogo a, Jogo b) {
	
    //Ideia: comparar os elementos em base com os em copia para alterar o tabuleiro sem medo
    
    //Problema: depois que a primeira linha e a primeira coluna inteira são preenchidas, a subrotina não atualiza mais a coluna após um certo elemento.
	
	printf("\n\t\t\t Digite um valor de 0 a 5\n\n\n");
	
	scanf("%i", &a.comando);
	
	//recebe o valor a ser aplicado no elemento do ponto inicial (armazena no registro base por praticidade, mas poderia ser armazenado na copia sem problemas)
	
    b.tab[0][0] = a.comando;
    
    //altera o primeiro elemento de acordo com o input

    Jogo c = analisar(a, b);
   
   //passa a versão modificada para um registro novo, que vai servir como base para a próxima alteração
    
    imprime(c);
    
    b = c;    
    
    jogada(c, b);
	
}	


   


int main () {
	
	Jogo base = novoTabuleiro();
	
	
	imprime(base);
    
    Jogo copia = base;
    
    copia.i = 1;
    copia.j = 1;
    
    jogada(base, copia);

	
	return 0;
}
